/*
 * cfg_init.c
 *
 *  Created on: 8 Mar 2022
 *      Author: muhammad.ahmad@georgekent.net
 */

#include "common.h"
#include "cfg.h"
#include "cfg_keys.h"

/*coap://223.25.247.73:36000/gkm-swmgt/latest*/

//Config_t config= {
//		.flash.configVersion= CFG_CONFIG_VERSION,
//		.flash.useDefaultConfig= false,
//		.flash.type= APP1_APP2_CFG_FlashType,
//
//#if PARTITION== 2
//		.flash.partition= PARTITION_2_FlashPartition,
//		.flash.partitionStartAddress= CFG_PARTITION_2_ADDR,
//#else
//		.flash.partition= PARTITION_1_FlashPartition,
//		.flash.partitionStartAddress= CFG_PARTITION_1_ADDR,
//#endif
//		.flash.partitionLength= CFG_PARTITION_SIZE,
//		.flash.partitionChecksum= 0x00000000,
//		.flash.failsafeWordA= FAILSAVE_CFG_WORD_A,
//
//		.system.checksum= 0x09abcdef,
//		.system.mcuFrequency= 24000000, /*4000000 16000000 24000000 48000000 80000000*/
//		.system.transmissionType= NBIOT_Transmission,
//		.system.hours= 0x00,
//		.system.minutes= 0x00,
//		.system.seconds= 0x00,
//		.system.weekday= LL_RTC_WEEKDAY_TUESDAY,
//		.system.day= 0x12,
//		.system.month= LL_RTC_MONTH_OCTOBER,
//		.system.year= 0x21,
//		.system.utc= ((8* 60)/ 15),/*UTC+8 in term of 15 minutes*/
//		.system.key.master= CFG_KEYS_KEY_MASTER,
//		.system.key.cfg.prod= CFG_KEYS_KEY_CFG_PROD,
//		.system.key.cfg.dev= CFG_KEYS_KEY_CFG_DEV,
//		.system.key.cfg.user= CFG_KEYS_KEY_CFG_USER,
//		.system.key.opr.a= CFG_KEYS_KEY_OPR_A,
//		.system.key.opr.b= CFG_KEYS_KEY_OPR_B,
//		.system.fwVersion= CFG_DEVICE_FIRMWARE_VERSION,
//		.system.hwVersion= CFG_DEVICE_HARDWARE_VERSION,
//		.system.mfcDate= EMPTY_STRING,
//		.system.uid= "00000001",
//		.system.serialNo= EMPTY_STRING,
//		.system.name= NAME_STRING,
//		.system.address= EMPTY_STRING,
//		.system.note= EMPTY_STRING,
//		.system.meterSerialNo= EMPTY_STRING,
//		.system.meterModel= 254- 1,
//		.system.latitude= 0,
//		.system.longitude= 0,
//		.system.rteDisableSleep= false,
//		.system.rteSysTick= 0,
//		.system.rteSysRequest= NONE_SysRequest,
//		.system.rteIsTurnedOn= false,
//		.system.rteSysRequestTimeDelay= 0,
//
//		.failsafe.failsafeWordB= FAILSAVE_CFG_WORD_B,
//		.failsafe.SWDGTimeout_ms= 25000,//25000,/*IWDG will force reset maximum at about 32sec, SWDG must timeout before that so that we can save config */
//		.failsafe.IWDGEnable= true,
//		.failsafe.IWDGPrescaler= LL_IWDG_PRESCALER_256,
//		.failsafe.IWDGReloadCounter= 0x0FFF,
//		.failsafe.WWDGEnable= false,
//		.failsafe.WWDGPrescaler= LL_WWDG_PRESCALER_8,
//		.failsafe.WWDGWindow= 0x7E,
//		.failsafe.PVDEnable= true,
//		.failsafe.PVDLevel= PWR_PVDLEVEL_3,//PWR_PVDLEVEL_3,
//		.failsafe.BORLevel= OB_BOR_LEVEL_1,
//		.failsafe.periodicCheckInterval_s= 3600,
//		.failsafe.resetLog= {{0}},
//		.failsafe.rteResetLogCounter= 0,
//		.failsafe.rtePC= 0,
//		.failsafe.rteResetFlags= 0,
//		.failsafe.saveConfigInterval_s= HOUR_TO_SECONDS(24),/*stm32l4 guaranteed write cycle max 10K*/
//		.failsafe.lwm2mIgnoreCycle= 12,
//		.failsafe.lwm2mAdditionMargin= 3,/*decada time window is within 1am to 4am*/
//		.failsafe.lwm2mMultiplierMargin= 3,/*decada KPI is within maximum 3 days*/
//
//		.diagnostic.queue.storage= 0,
//		.diagnostic.queue.head= 0,
//		.diagnostic.queue.elementCount= 0,
//		.diagnostic.queue.elementPopped= 0,
//		.diagnostic.queue.elementSize= DIAG_CFG_ENTRY_SIZE,
//		.diagnostic.queue.elementMax= DIAG_CFG_MAX_ENTRY,
//		.diagnostic.rteHardfaultRebootCount= 0,
//		.diagnostic.rteFailsafeRebootCount= 0,
//		.diagnostic.rtePVDRebootCount= 0,
//		.diagnostic.rteBORCount= 0,
//		.diagnostic.rteWatchdogRebootCount= 0,
//		.diagnostic.rteShutdownCount= 0,
//		.diagnostic.rteRebootCount= 0,
//		.diagnostic.rteVRefDippedCount= 0,
//		.diagnostic.rteNbModemSelfResetCount= 0,
//
//		.pulser.mode= TRACSENS_Mode,
//		.pulser.weight_liter= 0.25,
//		.pulser.rtePrevValue_liter= 0,
//		.pulser.rtePrevValue2_liter= 0,
//		.pulser.tracsens.enableErrorPatternCheck= true,
//		.pulser.tracsens.useCompensatedValue= false,
//		.pulser.tracsens.errorPatternConfirmationCount= 36,//6,
//		.pulser.tracsens.rteOffsetValue= 0,
//		.pulser.tracsens.rteLastSavedValue= 0,
//		.pulser.tracsens.rteErrorPatternCount= 0,
//		.pulser.tracsens.rteErrorPatternCompensationStarted= 0,
//		.pulser.tracsens.rteErrorPatternState= 0,
//		.pulser.tracsens.rteErrorPatternPreviousPulse= 0,
//		.pulser.tracsens.rteErrorPatternJustStarted= 0,
//		.pulser.lcsens.currBitmap= 0b0,
//		.pulser.lcsens.prevBitmap= 0b0,
//		.pulser.lcsens.transitionTable= {0},
//		.pulser.lcsens.initialTransitionVal= 0b0,
//		.pulser.lcsens.currTransitionVal= 0b0,
//		.pulser.lcsens.prevTransitionVal= 0b0,
//		.pulser.lcsens.fwdTransitionCnt= 0,
//		.pulser.lcsens.bwdTransitionCnt= 0,
//		.pulser.lcsens.fwdRevolutionCnt= 0,
//		.pulser.lcsens.bwdRevolutionCnt= 0,
//		.pulser.elster.rteOffsetValue= 0,
//		.pulser.elster.rteLastSavedValue= 0,
//		.pulser.rtePrevErrorPatternCount= 0,
//
//		.log.device.contextSaved= false,
//		.log.device.logConfigured= false,
//		.log.device.deviceLogEnabled= false,
//		.log.device.tamperLogEnabled= false,
//		.log.device.tickType= HOUR_TickType,
//		.log.device.tickSize= 1,
//		.log.device.startType= WAITSTARTTIME_StartType,
//		.log.device.startMarker.second= 0x00,/*in BCD*/
//		.log.device.startMarker.minute= 0x00,/*in BCD*/
//		.log.device.startMarker.hour= 0x00,/*in BCD*/
//		.log.device.startMarker.date= 0xFF,/*in BCD*/
//		.log.device.rte.nextTick= 1,
//		.log.device.rte.currentEEPROMAddress= 0,
//		.log.device.rte.logsInEEPROMFloorIndex= 0,
//		.log.device.rte.logsInEEPROMCeilingIndex= 0,
//		.log.device.rte.logCount= 0,
//		.log.device.rte.periodicLogCount= 0,
//		.log.device.rte.tamperLogCount= 0,
//		.log.device.rte.currentLogTimestamp= 0,
//
//		.sensors.taskInterval_ms= HOUR_TO_MILISECONDS(1),
//		.sensors.ADCSensorsSamplingInterval_ms= HOUR_TO_MILISECONDS(1),
//		.sensors.temperatureOffset= 0,
//		.sensors.battery.RSense= 0.1,/*in ohm*/
//		.sensors.battery.designCapacity_Ah= 14.0,/*Total 19.0. 3% discharge yearly. 12.0(15yrs) 14.0(10yrs)in Ah*/
//		.sensors.battery.lowThreshold= 10.0,
//		.sensors.battery.rtePrevQH= 0xFFFF,/*QH is counting down*/
//		.sensors.battery.rteQHMultiplier= 0,
//		.sensors.battery.rteMinCurrent= 99999,
//		.sensors.battery.rteMaxCurrent= 0,
//		.sensors.flow.enabled= true,
//		.sensors.flow.samplingPeriod_s= 60,
//		.sensors.flow.samplingTimeMultiplier= 1,
//		.sensors.flow.backflowThreshold= 16,
//		.sensors.flow.burstSamplingPeriod_s= 604800,
//		.sensors.flow.burstThreshold= 3500,
//		.sensors.flow.noflowSamplingPeriod_s= 604800,
//		.sensors.flow.leakageThreshold= 16,
//		.sensors.flow.leakageSamplingPeriod_s= 604800,
//		.sensors.flow.status.flowrate= 0,
//		.sensors.flow.status.flowrateMin= 3000,
//		.sensors.flow.status.flowrateMax= 0,
//		.sensors.flow.status.flowrateHourly= 0,
//		.sensors.flow.status.backflow= 0,
//		.sensors.flow.status.backflowMax= 0,
//		.sensors.flow.status.backflowFlag= false,
//		.sensors.flow.status.backflowDetected= false,
//		.sensors.flow.status.burstFlag= false,
//		.sensors.flow.status.burstDetected= false,
//		.sensors.flow.status.noflowFlag= false,
//		.sensors.flow.status.noflowDetected= false,
//		.sensors.flow.status.leakageFlag= false,
//		.sensors.flow.status.leakageDetected= false,
//		.sensors.flow.rte.prevReading_l= 0,
//		.sensors.flow.rte.backflow.prevDirection= 0,
//		.sensors.flow.rte.backflow.currValue= 0,
//		.sensors.flow.rte.backflow.prevValue= 0,
//		.sensors.flow.rte.backflow.prevMarker= 0,
//		.sensors.flow.rte.backflow.totalPulse= 0,
//		.sensors.flow.rte.backflow.valueMarker= 0,
//		.sensors.flow.rte.burst.samplingCount= 0,
//		.sensors.flow.rte.noflow.samplingCount= 0,
//		.sensors.flow.rte.leakage.samplingCount= 0,
//		.sensors.position.intArmedThreshold= 0x36,//0x3E/*80 degree*//*region of which 6D interrupt is generated*/
//		.sensors.position.intDisarmedThreshold= 0x1F,/*30 degree*//*clearance from threshold of which 6d interrupt of the axis need to be disabled*/
//		.sensors.position.intDisarmedThreshold= 0x1F,/*30 degree*//*clearance from threshold of which 6d interrupt of the axis need to be disabled*/
//
////		.alarm.backOffPeriod_ms= 60000,
////		.alarm.object[PBMAGCOUNT_Alarm]= 	{true, PBMAGCOUNT_Sensor, 			ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[TAMPERINCOUNT_Alarm]= {true, TAMPERINCOUNT_Sensor, 		ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[RSTAMPERCOUNT_Alarm]= {true, RSTAMPERCOUNT_Sensor, 		ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[VOLTAGE_Alarm]= 		{true, INTERNAL_VOLTAGE_Sensor, 	ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[TEMPERATURE_Alarm]= 	{true, INTERNAL_TEMPERATURE_Sensor, ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[CELLCAPACITY_Alarm]= 	{true, CELLCAPACITY_Sensor, 		ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[AVECURRENT_Alarm]= 	{true, AVECURRENT_Sensor, 			ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[POSITION_X_Alarm]= 	{true, POSITION_X_Sensor, 			ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[POSITION_Y_Alarm]= 	{true, POSITION_Y_Sensor, 			ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[POSITION_Z_Alarm]= 	{true, POSITION_Z_Sensor, 			ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[TILTCOUNT_Alarm]= 	{true, TILTCOUNT_Sensor, 			ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[PIPE_BURST_Alarm]= 	{true, PIPE_FLOWRATE_Sensor, 		ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[PIPE_EMPTY_Alarm]= 	{true, PIPE_FLOWRATE_Sensor, 		ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[PIPE_LEAK_Alarm]= 	{true, PIPE_BACKFLOW_Sensor, 		ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
////		.alarm.object[PIPE_BACKFLOW_Alarm]= {true, INTERNAL_VOLTAGE_Sensor, 	ABOVE_AND_EQUAL_AlarmThreshold, 1, AND_AlarmThreshold, NONE_AlarmThreshold, 0, 1, 15000},
//
//		.nbiot.apn= "nbiot",
//		.nbiot.pdpAddress= UNINIT_STRING,
//		.nbiot.imei= UNINIT_STRING,
//		.nbiot.imsi= UNINIT_STRING,
//		.nbiot.iccid= UNINIT_STRING,
//		.nbiot.modemMode= APPLICATION_ModemMode,
//		.nbiot.activeTime= 0,/*rrc drop, no need edrx,*/
//		.nbiot.periodicTau= (3600* 24),/*one day*/
//		.nbiot.edrx= 81920,
//		.nbiot.pagingTime= 2560,
//		.nbiot.delayBetweenCSQ_s= 2,
//		.nbiot.maximumCSQRetry= 240,
//		.nbiot.restartDelay_s= 157680000,/*5 years/off by default*///HOUR_TO_SECONDS(3),//(24* 60* 60),
//		.nbiot.maxUnknwonFailureAllowed= 3,
//		.nbiot.rteActiveTime= 0,
//		.nbiot.rtePeriodicTau= 0,
//		.nbiot.rteEdrx= 0,
//		.nbiot.rtePagingTime= 0,
//		.nbiot.stats.noOfTransmission= 0,
//		.nbiot.stats.noOfFailedTransmission= 0,
//		.nbiot.stats.noOfAttach= 0,
//		.nbiot.stats.noOfDisattach= 0,
//		.nbiot.stats.noOfSimError= 0,
//		.nbiot.stats.latency_ms= 0,
//		.nbiot.stats.aveLatency_ms= 0,
//		.nbiot.stats.minLatency_ms= 0xFFFF,
//		.nbiot.stats.maxLatency_ms= 0,
//		.nbiot.stats.pingLatency_ms= 0,
//		.nbiot.stats.failsafeRebootCount= 0,
//		.nbiot.stats.PVDRebootCount= 0,
//		.nbiot.stats.BORRebootCount= 0,
//		.nbiot.stats.rsrp= 0,
//		.nbiot.stats.aveRsrp= 0,
//		.nbiot.stats.minRsrp= 200,
//		.nbiot.stats.maxRsrp= -200,
//		.nbiot.stats.rssi= 0,
//		.nbiot.stats.aveRssi= 0,
//		.nbiot.stats.minRssi= 200,
//		.nbiot.stats.maxRssi= -200,
//		.nbiot.stats.sinr= 0,
//		.nbiot.stats.aveSinr= 0,
//		.nbiot.stats.minSinr= 127,
//		.nbiot.stats.maxSinr= -127,
//		.nbiot.stats.rsrq= 0,
//		.nbiot.stats.aveRsrq= 0,
//		.nbiot.stats.minRsrq= 127,
//		.nbiot.stats.maxRsrq= -127,
//		.nbiot.stats.txPower= 0,
//		.nbiot.stats.aveTxPower= 0,
//		.nbiot.stats.minTxPower= 255,
//		.nbiot.stats.maxTxPower= 0,
//		.nbiot.stats.ceMode= 0,
//		.nbiot.stats.ecl= 0,
//		.nbiot.stats.battVoltage_mV= 3600,
//		.nbiot.rteTotalLatency_ms= 0,
//		.nbiot.rteSignalSampleCount= 0,
//		.nbiot.rteTotalRsrp= 0,
//		.nbiot.rteTotalRssi= 0,
//		.nbiot.rteTotalSinr= 0,
//		.nbiot.rteTotalRsrq= 0,
//		.nbiot.rteTotalTxPower= 0,
//		.nbiot.enableRRCDrop= true,
//		.nbiot.RRCDropPeriod_s= 3,
//		.nbiot.downlinkWaitPeriod_s= 2,/*decada needs at least 2 seconds to reconnet mqtt, 5 seconds to send downlink command*/
//		.nbiot.enableAttachOnMagnetTamper= true,
//		.nbiot.enableAttachOnPulserThreshold= true,
//		.nbiot.pulserThresholdValueForAttach_liter= 500, /*must be more than production flow test value*/
//		.nbiot.enableAttachOnTiltTamper= false,
//		.nbiot.tiltTamperAttachBackoff_s= HOUR_TO_SECONDS(3),/*roughly handling during installation*/
//		.nbiot.enableGkcoapOnAttach= true,
//		.nbiot.enableLwm2mOnAttach= true,
//		.nbiot.backoffOnCereg0= false,
//		.nbiot.bypassBuckBoost= false,
//		.nbiot.fastModemReboot= false,/*don't skip before production done*/
//		.nbiot.reattachWait_s= 30,
//		.nbiot.gkcoap.enabled= false,
//		.nbiot.gkcoap.localPort= 56830,/*for bc66 coap AT commands*/
//		//.nbiot.gkcoap.activeServer= 1,
//		.nbiot.gkcoap.serverIP= "223.25.247.73",
//		.nbiot.gkcoap.serverPort= 5653,
//		.nbiot.gkcoap.serverURI= "/device",
//		.nbiot.gkcoap.fotaServerIP= "223.25.247.73",
//		.nbiot.gkcoap.fotaServerPort= 36000,
//		.nbiot.gkcoap.fotaServerURI= "/gkm-swmgt/latest",
//		//.nbiot.gkcoap.mode= BC66LINK_COAP_ENCRYPTION_NONE,
//		.nbiot.gkcoap.retryBackoffMin_s= 60,
//		.nbiot.gkcoap.retryBackoffMax_s= 360,
//		.nbiot.gkcoap.retryMax= 3,
//		.nbiot.gkcoap.packetType= 0x32,
//		.nbiot.gkcoap.logTickType= 2,
//		.nbiot.gkcoap.logTickSize= 1,
//		.nbiot.gkcoap.logTickStartMask= 0xFFFF0000,
//		.nbiot.gkcoap.reportStartMask= 0xFFFFFFFF00000000,/*0xYYMMDDhhmmss0000*/
//		.nbiot.gkcoap.reportInterval_s= HOUR_TO_SECONDS(24),
//		.nbiot.gkcoap.reportTriggerType= START_TIME_ReportTrigger,
//		.nbiot.gkcoap.reportTriggerLogCount= 0,
//		.nbiot.gkcoap.rteStartTime= 0,
//		.nbiot.gkcoap.rteNextTime= 0,
//		.nbiot.gkcoap.rte.reg.state= GKCOAP_REG_STATE_IDLE,
//		.nbiot.gkcoap.rte.reg.isRequested= true,
//		.nbiot.gkcoap.rte.reg.isCompleted= false,
//		.nbiot.gkcoap.rte.reg.retryCount= 0,
//		.nbiot.gkcoap.rte.report.state= GKCOAP_REPORT_STATE_IDLE,
//		.nbiot.gkcoap.rte.report.isRequested= false,
//		.nbiot.gkcoap.rte.report.isCompleted= false,
//		.nbiot.gkcoap.rte.report.retryCount= 0,
//		.nbiot.gkcoap.rte.report.noOfLogsToReport= 0,
//		.nbiot.gkcoap.rte.report.noOfLogsReported= 0,
//		.nbiot.gkcoap.rte.fota.state= Idle_FotaState,
//		.nbiot.gkcoap.rte.fota.isRequested= false,
//		.nbiot.gkcoap.rte.fota.isCompleted= false,
//		.nbiot.gkcoap.rte.fota.retryCount= 0,
//		.nbiot.gkcoap.alarmActivePeriod_s= 120,
//		.nbiot.gkcoap.rteAlarmClearTimestamp= 0,
//		.nbiot.lwm2m.enabled= false,
//		.nbiot.lwm2m.enableBootstrap= true,
//		.nbiot.lwm2m.defaultConnection.serverIP= "18.142.171.195",//"lwm2m.thingsboard.cloud",//"223.25.247.73", /*"leshan.eclipseprojects.io" "demo.gkmetering.com"*/
//		.nbiot.lwm2m.defaultConnection.serverPort= 5784,//36002,//5683,/*5683 5684(psk) 5783(bootstrap) 5784(bootstrap-PSK)*/
//		.nbiot.lwm2m.defaultConnection.endpointName= "",//"urn:imei:867997039346084",//"urn:imei:867997039345904",//"urn:imei:867997039346084",//"gk-default-endpoint",//"gk-test-00",
//		.nbiot.lwm2m.defaultConnection.lifetime_s= 86400,
//		.nbiot.lwm2m.defaultConnection.securityMode= PSK_Bc66LinkLwm2mSecurityMode,//NONE_Bc66LinkLwm2mSecurityMode, /*BC66LINK_LWM2M_SECURITY_MODE_NONE BC66LINK_LWM2M_SECURITY_MODE_PSK*/
//		.nbiot.lwm2m.defaultConnection.pskId= "GK",
//		.nbiot.lwm2m.defaultConnection.psk= "6B552929767446753678",
//		.nbiot.lwm2m.currentConnection.serverIP= "",
//		.nbiot.lwm2m.currentConnection.serverPort= 5683,
//		.nbiot.lwm2m.currentConnection.endpointName= "",
//		.nbiot.lwm2m.currentConnection.lifetime_s= 86400,
//		.nbiot.lwm2m.currentConnection.securityMode= NONE_Bc66LinkLwm2mSecurityMode,
//		.nbiot.lwm2m.currentConnection.pskId= "",
//		.nbiot.lwm2m.currentConnection.psk= "",
//		.nbiot.lwm2m.registerBackoff_s= 28800,
//		.nbiot.lwm2m.notifyACK= 1,
//		.nbiot.lwm2m.notifyRAI= 0,/*set to 0 by default because we have separate RAI handling*/
//		.nbiot.lwm2m.reregisterAfterPSM= false,
//		.nbiot.lwm2m.lwObj[SOFTWARE_MANAGEMENT_ObjName]= {
//				.type= SWMGT_ObjType,
//				.id= 9,
//				.version= 1.0,
//				.instance= FOTA_SwMgtInstance,
//				.resourceCount= MAX_SwMgtResource,
//				.resource= config.nbiot.lwm2m.swmgt.resource,
//				.rte.swMgt= &(config.nbiot.lwm2m.swmgt.rte),
//		},
//		.nbiot.lwm2m.lwObj[PRACT_GET_READING_ObjName]= {
//				.type= PRACT_ObjType,
//				.id= 10376,
//				.version = 1.0,
//				.instance= GET_READING_PractInstance,
//				.resourceCount= MAX_PractResource,
//				.resource= config.nbiot.lwm2m.pract.resource[GET_READING_PractInstance],
//				.rte.prAct= &(config.nbiot.lwm2m.pract.rte[GET_READING_PractInstance]),
//		},
//		.nbiot.lwm2m.lwObj[PRACT_GET_STATUS_ObjName]= {
//				.type= PRACT_ObjType,
//				.id= 10376,
//				.version = 1.0,
//				.instance= GET_STATUS_PractInstance,
//				.resourceCount= MAX_PractResource,
//				.resource= config.nbiot.lwm2m.pract.resource[GET_STATUS_PractInstance],
//				.rte.prAct= &(config.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance]),
//		},
//		.nbiot.lwm2m.lwObj[PRACT_QUERY_ObjName]= {
//				.type= PRACT_ObjType,
//				.id= 10376,
//				.version = 1.0,
//				.instance= QUERY_PractInstance,
//				.resourceCount= MAX_PractResource,
//				.resource= config.nbiot.lwm2m.pract.resource[QUERY_PractInstance],
//				.rte.prAct= &(config.nbiot.lwm2m.pract.rte[QUERY_PractInstance]),
//		},
//		.nbiot.lwm2m.lwObj[DTMON_ALARMS_ObjName]= {
//				.type= DTMON_ObjType,
//				.id= 10377,
//				.version = 1.0,
//				.instance= ALARMS_DtmonInstance,
//				.resourceCount= MAX_DtmonResource,
//				.resource= config.nbiot.lwm2m.dtmon.resource[ALARMS_DtmonInstance],
//				.rte.dtMon= &(config.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance]),
//		},
////		.nbiot.lwm2m.lwObj[DTMON_BACKFLOW_ObjName]= {
////				.type= DTMON_ObjType,
////				.id= 10377,
////				.version = 1.0,
////				.instance= BACKFLOW_DtmonInstance,
////				.resourceCount= MAX_DtmonResource,
////				.resource= config.nbiot.lwm2m.dtmon.resource[BACKFLOW_DtmonInstance],
////				.rte.dtMon= &(config.nbiot.lwm2m.dtmon.rte[BACKFLOW_DtmonInstance]),
////		},
//		.nbiot.lwm2m.swmgt.resource= {
//				{.attr= {PKG_NAME_SwMgtResource, READ_ResourceOperation, STRING_ResourceType}, .observe= true},
//				{.attr= {PKG_VERSION_SwMgtResource, READ_ResourceOperation, STRING_ResourceType}, .observe= true},
//				{.attr= {PACKAGE_SwMgtResource,  WRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {PACKAGE_URI_SwMgtResource, WRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.swmgt.uri, .valueMaxLen= SWMGT_CFG_URI_MAX_LEN},
//				{.attr= {INSTALL_SwMgtResource, EXECUTE_ResourceOperation, NONE_ResourceType}},
//				{.attr= {FILLER1_SwMgtResource,  READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {UNINSTALL_SwMgtResource, EXECUTE_ResourceOperation, NONE_ResourceType}},
//				{.attr= {UPDATE_STATE_SwMgtResource, READ_ResourceOperation, INTEGER_ResourceType}, .observe= true},
//				{.attr= {FILLER2_SwMgtResource,  READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {UPDATE_RESULT_SwMgtResource, READ_ResourceOperation, INTEGER_ResourceType}, .observe= true},
//				{.attr= {ACTIVATE_SwMgtResource, EXECUTE_ResourceOperation, NONE_ResourceType}},
//				{.attr= {DEACTIVATE_SwMgtResource, EXECUTE_ResourceOperation, NONE_ResourceType}},
//				{.attr= {ACTIVATION_STATE_SwMgtResource, READ_ResourceOperation, BOOLEAN_ResourceType}, .observe= true},
//		},
//		.nbiot.lwm2m.swmgt.uri= "",
//		.nbiot.lwm2m.pract.resource[GET_READING_PractInstance]= {
//				{.attr= {NAME_PractResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {DESC_PractResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {SETTINGS_PractResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.pract.practSetting0, .valueMaxLen= PRACT_CFG_0_SETTINGS_RESOURCE_MAX_LEN},
//				{.attr= {START_MASK_PractResource, READWRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.pract.startMask[GET_READING_PractInstance], .valueMaxLen= PRACT_CFG_MASK_RESOURCE_LEN},
//				{.attr= {PERIODIC_INTERVAL_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 3600},
//				{.attr= {RUN_PERIOD_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 0x00FFFFFF},/*if set all ff nanti stopped immediately cos + run period and overflowed*/
//				{.attr= {RECORD_PractResource, READ_ResourceOperation, OPAQUE_ResourceType}},
//				{.attr= {RECORD_HEAD_PractResource, READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_TAIL_PractResource, READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_READ_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_DISPATCH_START_MASK_PractResource, READWRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.pract.recordDispatchStartMask[GET_READING_PractInstance], .valueMaxLen= PRACT_CFG_MASK_RESOURCE_LEN},
//				{.attr= {RECORD_DISPATCH_PERIODIC_INTERVAL_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 3600},
//		},
//		.nbiot.lwm2m.pract.rte[GET_READING_PractInstance].runState= STOPPED_PractRunState,
//		.nbiot.lwm2m.pract.rte[GET_READING_PractInstance].log.partition= M95M01_PARTITION_PRACT_0,
//		.nbiot.lwm2m.pract.rte[GET_READING_PractInstance].log.head= 0,
//		.nbiot.lwm2m.pract.rte[GET_READING_PractInstance].log.elementCount= 0,
//		.nbiot.lwm2m.pract.rte[GET_READING_PractInstance].log.elementMax= PRACT_CFG_0_RECORD_RESOURCE_MAX_COUNT,
//		.nbiot.lwm2m.pract.rte[GET_READING_PractInstance].log.elementSize= sizeof(PRACT_GetReadingRecord_t),
//		.nbiot.lwm2m.pract.startMask[GET_READING_PractInstance]= "--------0000",
//		.nbiot.lwm2m.pract.recordDispatchStartMask[GET_READING_PractInstance]= "--------0000",
//		.nbiot.lwm2m.pract.resource[GET_STATUS_PractInstance]= {
//				{.attr= {NAME_PractResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {DESC_PractResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {SETTINGS_PractResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.pract.practSetting1, .valueMaxLen= PRACT_CFG_1_SETTINGS_RESOURCE_MAX_LEN},
//				{.attr= {START_MASK_PractResource, READWRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.pract.startMask[GET_STATUS_PractInstance], .valueMaxLen= PRACT_CFG_MASK_RESOURCE_LEN},
//				{.attr= {PERIODIC_INTERVAL_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 86400/2},/*when we have sent this, we have to wait until 12 hours to have a new one sampled*/
//				{.attr= {RUN_PERIOD_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 10000},
//				{.attr= {RECORD_PractResource, READ_ResourceOperation, OPAQUE_ResourceType}},
//				{.attr= {RECORD_HEAD_PractResource, READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_TAIL_PractResource, READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_READ_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_DISPATCH_START_MASK_PractResource, READWRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.pract.recordDispatchStartMask[GET_STATUS_PractInstance], .valueMaxLen= PRACT_CFG_MASK_RESOURCE_LEN},
//				{.attr= {RECORD_DISPATCH_PERIODIC_INTERVAL_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 86400},
//		},
//		.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance].runState= STOPPED_PractRunState,
//		.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance].log.partition= M95M01_PARTITION_PRACT_1,
//		.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance].log.head= 0,
//		.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance].log.elementCount= 0,
//		.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance].log.elementMax= PRACT_CFG_1_RECORD_RESOURCE_MAX_COUNT,
//		.nbiot.lwm2m.pract.rte[GET_STATUS_PractInstance].log.elementSize= sizeof(PRACT_GetStatusRecord_t),
//		.nbiot.lwm2m.pract.startMask[GET_STATUS_PractInstance]= "--------0000",
//		.nbiot.lwm2m.pract.recordDispatchStartMask[GET_STATUS_PractInstance]= "------000000",
//		.nbiot.lwm2m.pract.resource[QUERY_PractInstance]= {
//				{.attr= {NAME_PractResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {DESC_PractResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {SETTINGS_PractResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.pract.practSetting2, .valueMaxLen= PRACT_CFG_2_SETTINGS_RESOURCE_MAX_LEN},
//				{.attr= {START_MASK_PractResource, READWRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.pract.startMask[QUERY_PractInstance], .valueMaxLen= PRACT_CFG_MASK_RESOURCE_LEN},
//				{.attr= {PERIODIC_INTERVAL_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 86400},
//				{.attr= {RUN_PERIOD_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 1},
//				{.attr= {RECORD_PractResource, READ_ResourceOperation, OPAQUE_ResourceType}},
//				{.attr= {RECORD_HEAD_PractResource, READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_TAIL_PractResource, READ_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_READ_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RECORD_DISPATCH_START_MASK_PractResource, READWRITE_ResourceOperation, STRING_ResourceType}, .observe= false, .value.string= config.nbiot.lwm2m.pract.recordDispatchStartMask[QUERY_PractInstance], .notifyState= IDLE_NotifyState, .valueMaxLen= PRACT_CFG_MASK_RESOURCE_LEN},
//				{.attr= {RECORD_DISPATCH_PERIODIC_INTERVAL_PractResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 86400},
//		},
//		.nbiot.lwm2m.pract.rte[QUERY_PractInstance].runState= STOPPED_PractRunState,
//		.nbiot.lwm2m.pract.rte[QUERY_PractInstance].log.partition= M95M01_PARTITION_PRACT_2,
//		.nbiot.lwm2m.pract.rte[QUERY_PractInstance].log.head= 0,
//		.nbiot.lwm2m.pract.rte[QUERY_PractInstance].log.elementCount= 0,
//		.nbiot.lwm2m.pract.rte[QUERY_PractInstance].log.elementMax= PRACT_CFG_2_RECORD_RESOURCE_MAX_COUNT,
//		.nbiot.lwm2m.pract.rte[QUERY_PractInstance].log.elementSize= sizeof(PRACT_QueryRecord_t),
//		.nbiot.lwm2m.pract.startMask[QUERY_PractInstance]= "------000000",
//		.nbiot.lwm2m.pract.recordDispatchStartMask[QUERY_PractInstance]= "------000000",
//		.nbiot.lwm2m.dtmon.resource[ALARMS_DtmonInstance]= {
//				{.attr= {NAME_DtmonResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {DESC_DtmonResource, READ_ResourceOperation, STRING_ResourceType}},
//				{.attr= {SETTINGS_DtmonResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.dtmon.settings[ALARMS_DtmonInstance], .valueMaxLen= DTMON_CFG_SETTINGS_RESOURCE_MAX_LEN},
//				{.attr= {DATA_DtmonResource, READ_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.dtmon.data[ALARMS_DtmonInstance], .valueMaxLen= DTMON_CFG_RESULTS_VALUE_LEN},
//				{.attr= {SAMPLING_START_MASK_DtmonResource, READWRITE_ResourceOperation, STRING_ResourceType}, .value.string= config.nbiot.lwm2m.dtmon.samplingStartMask[ALARMS_DtmonInstance], .valueMaxLen= DTMON_CFG_MASK_RESOURCE_LEN},
//				{.attr= {SAMPLING_INTERVAL_DtmonResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 30},
//				{.attr= {SAMPLING_RUN_PERIOD_DtmonResource, READWRITE_ResourceOperation, INTEGER_ResourceType}, .value.integer= 86400},
//				{.attr= {REFERENCE_A_DtmonResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.dtmon.referenceA[ALARMS_DtmonInstance], .valueMaxLen= DTMON_CFG_REF_RESOURCE_LEN},
//				{.attr= {COMPARISON_A_DtmonResource, READWRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {REFERENCE_B_DtmonResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.dtmon.referenceB[ALARMS_DtmonInstance], .valueMaxLen= DTMON_CFG_REF_RESOURCE_LEN},
//				{.attr= {COMPARISON_B_DtmonResource, READWRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {REFERENCE_C_DtmonResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}, .value.opaque= config.nbiot.lwm2m.dtmon.referenceC[ALARMS_DtmonInstance], .valueMaxLen= DTMON_CFG_REF_RESOURCE_LEN},
//				{.attr= {COMPARISON_C_DtmonResource, READWRITE_ResourceOperation, INTEGER_ResourceType}},
//				{.attr= {RESULTS_DtmonResource, READWRITE_ResourceOperation, OPAQUE_ResourceType}},
//		},
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].log.partition= M95M01_PARTITION_DTMON_0,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].log.head= 0,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].log.elementCount= 0,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].log.elementMax= DTMON_CFG_RESULTS_RESOURCE_MAX_COUNT,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].log.elementSize= sizeof(DTMON_Result_t),
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].resultIndex= 0,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].prevResultValue= 0,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].settings.alarms.rteClearTimestamp= 0,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].settings.alarms.activePeriod_s= 86400,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].settings.alarms.lowBatteryLevel_percent= 8,
//		.nbiot.lwm2m.dtmon.rte[ALARMS_DtmonInstance].settings.alarms.nrtBackflowSamplingPeriod_s= 86400,
//		.nbiot.lwm2m.dtmon.samplingStartMask[ALARMS_DtmonInstance]= "------------",
//		.nbiot.lwm2m.dtmon.referenceA[ALARMS_DtmonInstance]= DTMON_CFG_DATA_REF_RESOURCE_DEFAULT,
//		.nbiot.lwm2m.dtmon.referenceB[ALARMS_DtmonInstance]= DTMON_CFG_DATA_REF_RESOURCE_DEFAULT,
//		.nbiot.lwm2m.dtmon.referenceC[ALARMS_DtmonInstance]= DTMON_CFG_DATA_REF_RESOURCE_DEFAULT,
//		.nbiot.lwm2m.diversifyPractDispatchMask= false,/*no point diversify before sno injection*/
//		.nbiot.lwm2m.practDispatchMaskInterval= 3,
//		.nbiot.lwm2m.practDispatchMaskPeriod= 7199,
//		.nbiot.lwm2m.practDispatchMaskOffset= 3600,/*pub: 1am - 4am transmit but we chose 1am - 3am to account for transmission buffer*/
//		.nbiot.lwm2m.notifyRetryBackoffMin_s= 300,
//		.nbiot.lwm2m.notifyRetryBackoffMax_s= 900,
//		.nbiot.lwm2m.useCellTemperature= true,
//};
