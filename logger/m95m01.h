/*
 * eeprom.h
 *
 *  Created on: 14 May 2018
 *      Author: muhammad.ahmad@georgekent.net
 */

#ifndef METER_LOG_M95M01_H_
#define METER_LOG_M95M01_H_

#include "main.h"
//#include "nbiot_define.h"

/*NOTE: Bare in mind our strategy of implementing eeprom is to write page by page basis, cos page write(256 bytes) is equal to byte write which is 5ms.
 * Thus, before writing to eeprom, the logger(both Meter/Radio logs) has to accumulate 256 bytes in RAM first.
 * As a result, log size has to be divisible by 256(1, 2, 4, 8, 16, 32, 64, 128, 256)*/

//#define M95M01_CFG_SIZE						(0x0001FFFF+ 1)
#define M95M01_CFG_PAGE_SIZE					(0xFF+ 1)

#define M95M01_CFG_PARTITION_NONE_START_ADDR	(0x00000000)
#define M95M01_CFG_PARTITION_NONE_LAST_ADDR		(0x0001FFFF)
#define M95M01_CFG_PARTITION_NONE_SIZE			((M95M01_CFG_PARTITION_NONE_LAST_ADDR- M95M01_CFG_PARTITION_NONE_START_ADDR)+ 1)

#define M95M01_CFG_PARTITION_1_START_ADDR		(0x00000000)
#define M95M01_CFG_PARTITION_1_SIZE				(PRACT_CFG_0_RECORD_RESOURCE_MAX_COUNT* (PRACT_CFG_0_RECORD_VALUE_LEN))
#define M95M01_CFG_PARTITION_1_LAST_ADDR		(M95M01_CFG_PARTITION_1_START_ADDR + M95M01_CFG_PARTITION_1_SIZE)

#define M95M01_CFG_PARTITION_2_START_ADDR		(M95M01_CFG_PARTITION_1_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_2_SIZE				(PRACT_CFG_1_RECORD_RESOURCE_MAX_COUNT* (PRACT_CFG_1_RECORD_VALUE_LEN))
#define M95M01_CFG_PARTITION_2_LAST_ADDR		(M95M01_CFG_PARTITION_2_START_ADDR + M95M01_CFG_PARTITION_2_SIZE)

#define M95M01_CFG_PARTITION_3_START_ADDR		(M95M01_CFG_PARTITION_2_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_3_SIZE				(PRACT_CFG_2_RECORD_RESOURCE_MAX_COUNT* (PRACT_CFG_2_RECORD_VALUE_LEN))
#define M95M01_CFG_PARTITION_3_LAST_ADDR		(M95M01_CFG_PARTITION_3_START_ADDR + M95M01_CFG_PARTITION_3_SIZE)

#define M95M01_CFG_PARTITION_4_START_ADDR		(M95M01_CFG_PARTITION_3_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_4_SIZE				(DTMON_CFG_RESULTS_RESOURCE_MAX_COUNT* (DTMON_CFG_RESULTS_VALUE_LEN))
#define M95M01_CFG_PARTITION_4_LAST_ADDR		(M95M01_CFG_PARTITION_4_START_ADDR + M95M01_CFG_PARTITION_4_SIZE)

#define M95M01_CFG_PARTITION_5_START_ADDR		(M95M01_CFG_PARTITION_4_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_5_SIZE				(DTMON_CFG_RESULTS_RESOURCE_MAX_COUNT* (DTMON_CFG_RESULTS_VALUE_LEN))
#define M95M01_CFG_PARTITION_5_LAST_ADDR		(M95M01_CFG_PARTITION_5_START_ADDR + M95M01_CFG_PARTITION_5_SIZE)

#define M95M01_CFG_PARTITION_6_START_ADDR		(M95M01_CFG_PARTITION_5_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_6_SIZE				(DTMON_CFG_RESULTS_RESOURCE_MAX_COUNT* (DTMON_CFG_RESULTS_VALUE_LEN))
#define M95M01_CFG_PARTITION_6_LAST_ADDR		(M95M01_CFG_PARTITION_6_START_ADDR + M95M01_CFG_PARTITION_6_SIZE)

#define M95M01_CFG_PARTITION_7_START_ADDR		(M95M01_CFG_PARTITION_6_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_7_SIZE				(DTMON_CFG_RESULTS_RESOURCE_MAX_COUNT* (DTMON_CFG_RESULTS_VALUE_LEN))
#define M95M01_CFG_PARTITION_7_LAST_ADDR		(M95M01_CFG_PARTITION_7_START_ADDR + M95M01_CFG_PARTITION_7_SIZE)

#define M95M01_CFG_PARTITION_8_START_ADDR		(M95M01_CFG_PARTITION_7_LAST_ADDR+ 1)
#define M95M01_CFG_PARTITION_8_SIZE				58560/*61 days*/
#define M95M01_CFG_PARTITION_8_LAST_ADDR		(M95M01_CFG_PARTITION_8_START_ADDR + M95M01_CFG_PARTITION_8_SIZE)

/* EEPROM SPI commands */
#define M95M01_CMD_WREN			0x06    /* Write Enable*/
#define M95M01_CMD_WRDI    		0x04    /* Write Disable*/
#define M95M01_CMD_RDSR    		0x05    /* Read Status Register*/
#define M95M01_CMD_WRSR    		0x01    /* Write Status Register*/
#define M95M01_CMD_READ    		0x03    /* Read from Memory Array*/
#define M95M01_CMD_WRITE   		0x02    /* Write to Memory Array*/
/* EEPROM SPI status */
#define M95M01_STATUS_SRWD    	0x80    /* Status Register Write Disable*/
#define M95M01_STATUS_BP      	0x0C    /* Block Protect*/
#define M95M01_STATUS_WEL     	0x02    /* Write Enable*/
#define M95M01_STATUS_WIP     	0x01    /* Write in Progress*/

#define M95M01_CFG_READ_OFFSET		5/*before 5th byte are rubbish*/
#define M95M01_CFG_TXBYTES_SIZE		(4+ M95M01_CFG_PAGE_SIZE)
#define M95M01_CFG_RXBYTES_SIZE		(M95M01_CFG_READ_OFFSET+ (M95M01_CFG_PAGE_SIZE* 2))
#define M95M01_CFG_MAX_TRX_QUEUE 2

typedef enum
{
	M95M01_PARTITION_NONE= 0,
	M95M01_PARTITION_PRACT_0= 1,
	M95M01_PARTITION_PRACT_1= 2,
	M95M01_PARTITION_PRACT_2= 3,
	M95M01_PARTITION_DTMON_0= 4,
	M95M01_PARTITION_DTMON_1= 5,
	M95M01_PARTITION_DTMON_2= 6,
	M95M01_PARTITION_DTMON_3= 7,
	M95M01_PARTITION_DEVICELOG= 8,
	M95M01_PARTITION_MAX
}M95M01_Partition;

typedef enum
{
    M95M01_TYPE_WRITE= 0,
    M95M01_TYPE_READ,
} M95M01_Transaction_Types;

typedef enum
{
    M95M01_STATUS_SUCCESS = 0,
    M95M01_STATUS_BUSY,
    M95M01_STATUS_TXRX_TIMEOUT,
    M95M01_STATUS_VALIDATE_ERROR,
    M95M01_STATUS_UNSUPPORTED_JOB
}M95M01_Transaction_Status;

typedef enum
{
    M95M01_WRITE_STATE_IDLE= 0,
    M95M01_WRITE_STATE_INITIALIZE,
    M95M01_WRITE_STATE_READ_RDSR_REGISTER,
    M95M01_WRITE_STATE_CHECK_WRITE_BUSY,
    M95M01_WRITE_STATE_SET_WRITE_ENABLE,
    M95M01_WRITE_STATE_WRITE_DATA_1,
    M95M01_WRITE_STATE_WRITE_DATA_2,
    M95M01_WRITE_STATE_WRITE_DATA_3,
    M95M01_WRITE_STATE_READ_RDSR_REGISTER_2,
    M95M01_WRITE_STATE_CHECK_WRITE_BUSY_2,
    M95M01_WRITE_STATE_VALIDATE_DATA_1,
    M95M01_WRITE_STATE_VALIDATE_DATA_2,
} M95M01_Transaction_Write_States;

typedef enum
{
    M95M01_READ_STATE_IDLE= 0,
    M95M01_READ_STATE_READ_DATA_1,
    M95M01_READ_STATE_READ_DATA_2,
    M95M01_READ_STATE_READ_DATA_3,
    M95M01_READ_STATE_READ_DATA_4
} M95M01_Transaction_Read_States;

typedef union
{
	M95M01_Transaction_Write_States write;
	M95M01_Transaction_Read_States read;
}M95M01_Transaction_States;

typedef struct
{
	M95M01_Transaction_Types type;
	M95M01_Transaction_States state;
	M95M01_Partition partition;
    uint8_t *dataPtr;
    uint16_t dataLen;
    uint32_t dataAddress;
    uint32_t timeout;
    uint8_t retryCounter;
    M95M01_Transaction_Status status;
	__IO bool transactionInQueue;
	__IO bool transactionInProgress;
	__IO bool transactionCompleted;
	void (*TransactionCompletedCb)(void);
}M95M01_Transaction_t;

uint8_t M95M01_QueueDepth(void);
ErrorStatus M95M01_Enqueue(M95M01_Transaction_t *_task);
M95M01_Transaction_t *M95M01_Dequeue(void);
void M95M01_Init(void);
void M95M01_Transaction(void);
M95M01_Transaction_Status M95M01_GetTrxStatus(void);
bool M95M01_GetM95M01AccessErrorFlag(void);
void M95M01_ClearM95M01AccessErrorFlag(void);
uint8_t M95M01_TransactionState(void);

#endif /* METER_LOG_M95M01_H_ */
